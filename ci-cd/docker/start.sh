#!/usr/bin/env bash
# start.sh - helper to update .env with current LAN IP/hostname and control the docker-compose stack
# Usage:
#   ./start.sh up               # update .env and start (docker compose up -d --build)
#   ./start.sh up --no-env      # start without updating .env
#   ./start.sh down             # docker compose down -v
#   ./start.sh restart          # update .env, recreate containers
#   ./start.sh logs             # follow logs
#   ./start.sh ps               # show compose ps
#   ./start.sh update-env [FALLBACK_CSV]
#       - regenerate .env; optional comma-separated fallback list to include
#   ./start.sh help

set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"
ENV_FILE=".env"

# Detect LAN IP on macOS (en0/en1) and fallback to generic ifconfig parsing.
detect_ip() {
  local ip
  ip=$(ipconfig getifaddr en0 2>/dev/null || true)
  if [ -z "$ip" ]; then
    ip=$(ipconfig getifaddr en1 2>/dev/null || true)
  fi
  if [ -z "$ip" ]; then
    # fallback: pick first non-loopback IPv4 from ifconfig
    ip=$(ifconfig 2>/dev/null | awk '/inet / && $2!~/127.0.0.1/ {print $2; exit}' || true)
  fi
  echo "$ip"
}

# Read a value from existing .env (key without interpolation)
read_env_value() {
  local key="$1"
  if [ -f "$ENV_FILE" ]; then
    # grep the first matching line, support KEY=value or KEY="value"
    local line
    line=$(grep -E "^${key}=" "$ENV_FILE" || true)
    if [ -n "$line" ]; then
      echo "${line#*=}" | sed 's/^\"//;s/\"$//'
      return 0
    fi
  fi
  return 1
}

# Build and write .env
update_env_file() {
  local provided_fallbacks="$1" # comma-separated optional
  local dry_run="${2:-false}"
  echo "Detecting LAN IP and local hostname..."
  local detected_ip
  detected_ip=$(detect_ip || true)
  local hostname
  hostname=$(scutil --get LocalHostName 2>/dev/null || hostname)

  local prev_primary
  prev_primary=$(read_env_value KAFKA_ADVERTISED_IP || true)
  prev_primary=${prev_primary:-}
  local prev_fallbacks
  prev_fallbacks=$(read_env_value KAFKA_ADVERTISED_IP_FALLBACKS || true)
  prev_fallbacks=${prev_fallbacks:-}

  # Prepare fallback list: keep previous primary (if different), previous fallbacks,
  # any provided fallbacks, then common useful entries.
  # initialize empty array (avoid unbound variable with set -u)
  fallback_arr=()

  # helper to push unique
  push_unique() {
    local val="$1"
    if [ -z "$val" ]; then return; fi
    for e in "${fallback_arr[@]:-}"; do
      if [ "$e" = "$val" ]; then return; fi
    done
    fallback_arr+=("$val")
  }

  # Prior primary (if set and not equal to detected)
  if [ -n "$prev_primary" ] && [ "$prev_primary" != "$detected_ip" ]; then
    push_unique "$prev_primary"
  fi
  # previous fallbacks
  if [ -n "$prev_fallbacks" ]; then
    IFS=',' read -ra pf <<< "$prev_fallbacks"
    for v in "${pf[@]:-}"; do push_unique "$v"; done
  fi
  # provided fallbacks (argument)
  if [ -n "$provided_fallbacks" ]; then
    IFS=',' read -ra pf2 <<< "$provided_fallbacks"
    for v in "${pf2[@]:-}"; do push_unique "$v"; done
  fi
  # always useful fallbacks
  push_unique "host.docker.internal"
  push_unique "127.0.0.1"

  # Join fallbacks into CSV
  local fallback_csv=""
  for v in "${fallback_arr[@]:-}"; do
    if [ -z "$fallback_csv" ]; then fallback_csv="$v"; else fallback_csv="$fallback_csv,$v"; fi
  done

  # Decide primary IP: prefer detected, else previous primary, else empty
  local primary_ip
  if [ -n "$detected_ip" ]; then
    primary_ip="$detected_ip"
  else
    primary_ip="$prev_primary"
  fi

  if [ -z "$primary_ip" ]; then
    echo "Warning: no primary LAN IP detected and none present in existing .env. You may need to set KAFKA_ADVERTISED_IP in $ENV_FILE manually."
  fi

  cat > "$ENV_FILE" <<EOF
# Generated by start.sh on $(date --iso-8601=seconds 2>/dev/null || date)
# primary advertised IP (used by EXTERNAL_IP listener)
KAFKA_ADVERTISED_IP=${primary_ip}
# Comma-separated fallbacks that clients may try if primary changes (not directly used by compose)
KAFKA_ADVERTISED_IP_FALLBACKS=${fallback_csv}
KAFKA_ADVERTISED_HOSTNAME=${hostname}.local

# Zookeeper & Kafka images (pin to specific versions)
ZOOKEEPER_IMAGE=confluentinc/cp-zookeeper:7.9.4
KAFKA_IMAGE=confluentinc/cp-kafka:7.9.4
CLNUI_TOOLS_IMAGE=clnui-tools:latest

# Build args for clnui-tools
KAFKA_VERSION=3.6.1
SCALA_VERSION=2.13
EOF

  if [ "$dry_run" = "true" ]; then
    echo "DRY RUN: would write .env with:"
    sed -n '1,200p' "$ENV_FILE"
    # restore previous content (don't overwrite) by removing the file created above
    rm -f "$ENV_FILE"
    return 0
  fi

  echo ".env written: KAFKA_ADVERTISED_IP=${primary_ip:-<empty>}, KAFKA_ADVERTISED_IP_FALLBACKS=${fallback_csv:-<empty>}, KAFKA_ADVERTISED_HOSTNAME=${hostname}.local"
}

# Wait for services to report healthy via docker-compose healthchecks
wait_for_health() {
  local timeout_secs=${1:-60}
  local poll_interval=${2:-3}
  local elapsed=0
  echo "Waiting for services to become healthy (timeout ${timeout_secs}s)..."
  while [ $elapsed -lt $timeout_secs ]; do
    # use docker compose ps --format to check health if supported, else fall back to docker inspect
    if docker compose ps --format "{{.Service}} {{.Status}}" 2>/dev/null | grep -q "(healthy)"; then
      echo "At least one service reports healthy - continuing."
      return 0
    fi
    sleep $poll_interval
    elapsed=$((elapsed + poll_interval))
  done
  echo "Timed out waiting for healthchecks after ${timeout_secs}s." >&2
  return 1
}

compose_up() {
  echo "Starting docker compose (up -d --build)..."
  docker compose up -d --build --remove-orphans
}

compose_down() {
  echo "Stopping docker compose (down -v)..."
  docker compose down -v
}

compose_logs() {
  docker compose logs -f
}

compose_ps() {
  docker compose ps
}

show_help() {
  cat <<'HELP'
start.sh - manage the local ci-cd/docker stack and .env

Usage: ./start.sh <command> [arg]

Commands:
  up [FALLBACK_CSV|--no-env]
      Update .env (unless --no-env) and start the docker compose stack (docker compose up -d --build).
      If a second argument is provided and not "--no-env", it is treated as a comma-separated
      list of fallback addresses to include in KAFKA_ADVERTISED_IP_FALLBACKS.

  down
      Stop and remove the stack (docker compose down -v).

  restart [FALLBACK_CSV]
      Update .env (optionally with provided fallbacks), then stop and start the stack.

  logs
      Follow docker compose logs (docker compose logs -f).

  ps
      Show docker compose ps output.

  update-env [FALLBACK_CSV] [--dry-run]
      Regenerate the .env file only. Optionally provide a comma-separated fallback list.
      If --dry-run is provided as the second arg, the script will print the proposed .env
      and will NOT write it to disk.

  help, -h, --help
      Show this help text.

Notes:
  - The script writes ci-cd/docker/.env with KAFKA_ADVERTISED_IP, KAFKA_ADVERTISED_IP_FALLBACKS,
    and KAFKA_ADVERTISED_HOST. The compose file reads the primary advertised IP/host.
  - KAFKA_ADVERTISED_IP_FALLBACKS is informational/documentation for clients to try other addresses
    when the primary IP changes (e.g., previous LAN IP, host.docker.internal, 127.0.0.1).
  - Use the --no-env flag with "up" if you want to start the stack without modifying .env.

Examples:
  ./start.sh up
  ./start.sh up --no-env
  ./start.sh update-env 192.168.0.35,backup-host.local
  ./start.sh update-env 192.168.0.35 --dry-run
  ./start.sh restart
HELP
}

case "${1:-up}" in
  up|start)
    # support optional flag --no-env
    if [ "${2:-}" = "--no-env" ] || [ "${2:-}" = "-n" ]; then
      compose_up
      # wait a bit for health (best-effort)
      wait_for_health 60 3 || true
    else
      # allow passing optional fallback list as second arg when invoking up
      update_env_file "${2:-}" "false"
      compose_up
      wait_for_health 60 3 || true
    fi
    ;;
  down|stop)
    compose_down
    ;;
  restart)
    update_env_file "${2:-}" "false"
    compose_down
    compose_up
    wait_for_health 60 3 || true
    ;;
  logs)
    compose_logs
    ;;
  ps)
    compose_ps
    ;;
  update-env)
    # support optional --dry-run as the second arg
    if [ "${2:-}" = "--dry-run" ] || [ "${3:-}" = "--dry-run" ]; then
      update_env_file "${2:-}" "true"
    else
      update_env_file "${2:-}" "false"
    fi
    ;;
  help|-h|--help)
    show_help
    ;;
  *)
    echo "Unknown command: ${1:-}" >&2
    show_help
    exit 2
    ;;
esac
